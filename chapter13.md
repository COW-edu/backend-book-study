# 13장 - 서브클래싱과 서브타이핑

## 🔴 빨강 (아주 중요하다고 생각한 내용!)
- **객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. (438)**
- **따라서 슈퍼타입과 서브타입 관계에서는 is-a 관계보다 행동 호환성이 더 중요하다. (445)**
- 요점은 자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중하라는 것이다. (451)

## 🔵 파랑 (중요하다고 생각한 내용!)
- 상속의 첫 번째 용도는 타입 계층을 구현하는 것이다. (435)
- 상속의 두 번째 용도는 코드 재사용이다. (435)
- 결론부터 말하자면 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다. (435)
- 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 부른다. (437)
- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다. (437)
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다. (437)
- **따라서 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의한 것이다. (438)**
- **객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이라는 사실을 기억하라. (439)**
- 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다. (443)
- 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다. (443)
- **클라이언트의 관점에서 두 클래스에 대해 기대하는 행동이 다르다면 비록 그것이 어휘적으로 is-a관계로 표현될 수 있다고 하더라도 상속을 사용해서는 안 된다. (444)**
- 결론은 두 타입 사이의 행동이 호환될 경우에만 타입 계층으로 묶어야 한다는 것이다. (445)
- **클라이언트에 따라 인터페이스를 분리하면 각 클라이언트의 요구가 바뀌더라도 영향의 파급 효과를 효과적으로 제어할 수 있다. (450)**
- 중요한 것은 설계가 반영할 도메인의 요구사항이고 그 안에서 클라이언트가 객체에게 요구하는 행동이다. (451)
- 이것이 서브타이핑을 인터페이스 상속이라고 부르는 이유다. 그에 반해 서브클래싱은 클래스의 내부 구현 자체를 상속받는 것에 초점을 맞추기 때문에 구현 상속 또는 클래스 상속이라고 부른다. (453)
- 리스코프 치환을 한 마디로 정리하면 "서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다"는 것으로 클라이언트가 "차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다"는 것이다. (453)
- 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다. (457)
- 상속 관계는 클라이언트 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바르다. (458)
- 대체 가능성을 결정하는 것을 클라이언트다. (458)
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야 한다. (461)
- 계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있따는 것이다. (465)
- **어떤 타입이 슈퍼타입에서 정의한 사전조건보다 더 약한 사전조건을 정의하고 있다면 그 타입은 서브타입이 될 수 있지만 더 강한 사전조건을 정의한다면 서브타입이 될 수 없다. (468)**
- 어떤 타입이 슈퍼타입에서 정의한 사후조건보다 더 강한 사후조건을 정의하더라도 그 타입은 여전히 서브타입이지만 더 약한 사후조건을 정의한다면 서브타입의 조건이 깨지고 만다. (468)


## 🟢 초록 (흥미롭다고 생각한 내용!)
- 
